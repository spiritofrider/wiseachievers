{"ast":null,"code":"/*\n Highcharts JS v10.0.0 (2022-03-07)\n\n 3D features for Highcharts JS\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-3d\", [\"highcharts\"], function (E) {\n    a(E);\n    a.Highcharts = E;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function E(a, w, t, D) {\n    a.hasOwnProperty(w) || (a[w] = D.apply(null, t), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: w,\n        module: a[w]\n      }\n    })));\n  }\n\n  a = a ? a._modules : {};\n  E(a, \"Extensions/Math3D.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, w) {\n    function t(d, c, b) {\n      c = 0 < b && b < Number.POSITIVE_INFINITY ? b / (d.z + c.z + b) : 1;\n      return {\n        x: d.x * c,\n        y: d.y * c\n      };\n    }\n\n    function F(d, c, b, f) {\n      var q = c.options.chart.options3d,\n          a = x(f, b ? c.inverted : !1),\n          e = {\n        x: c.plotWidth / 2,\n        y: c.plotHeight / 2,\n        z: q.depth / 2,\n        vd: x(q.depth, 1) * x(q.viewDistance, 0)\n      },\n          n = c.scale3d || 1;\n      f = k * q.beta * (a ? -1 : 1);\n      q = k * q.alpha * (a ? -1 : 1);\n      var u = Math.cos(q),\n          p = Math.cos(-f),\n          l = Math.sin(q),\n          C = Math.sin(-f);\n      b || (e.x += c.plotLeft, e.y += c.plotTop);\n      return d.map(function (b) {\n        var c = (a ? b.y : b.x) - e.x;\n        var d = (a ? b.x : b.y) - e.y;\n        b = (b.z || 0) - e.z;\n        c = {\n          x: p * c - C * b,\n          y: -l * C * c + u * d - p * l * b,\n          z: u * C * c + l * d + u * p * b\n        };\n        d = t(c, e, e.vd);\n        d.x = d.x * n + e.x;\n        d.y = d.y * n + e.y;\n        d.z = c.z * n + e.z;\n        return {\n          x: a ? d.y : d.x,\n          y: a ? d.x : d.y,\n          z: d.z\n        };\n      });\n    }\n\n    function f(d, c) {\n      var b = c.options.chart.options3d,\n          f = c.plotWidth / 2;\n      c = c.plotHeight / 2;\n      b = x(b.depth, 1) * x(b.viewDistance, 0) + b.depth;\n      return Math.sqrt(Math.pow(f - x(d.plotX, d.x), 2) + Math.pow(c - x(d.plotY, d.y), 2) + Math.pow(b - x(d.plotZ, d.z), 2));\n    }\n\n    function z(d) {\n      var c = 0,\n          b;\n\n      for (b = 0; b < d.length; b++) {\n        var f = (b + 1) % d.length;\n        c += d[b].x * d[f].y - d[f].x * d[b].y;\n      }\n\n      return c / 2;\n    }\n\n    function v(d, c, b) {\n      return z(F(d, c, b));\n    }\n\n    var x = w.pick,\n        k = a.deg2rad;\n    a.perspective3D = t;\n    a.perspective = F;\n    a.pointCameraDistance = f;\n    a.shapeArea = z;\n    a.shapeArea3d = v;\n    return {\n      perspective: F,\n      perspective3D: t,\n      pointCameraDistance: f,\n      shapeArea: z,\n      shapeArea3D: v\n    };\n  });\n  E(a, \"Core/Renderer/SVG/SVGElement3D.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, w, t) {\n    var F = a.parse,\n        f = t.defined;\n    a = t.merge;\n    var z = t.objectEach,\n        v = t.pick,\n        x = {\n      base: {\n        initArgs: function (f) {\n          var d = this,\n              c = d.renderer,\n              b = c[d.pathType + \"Path\"](f),\n              a = b.zIndexes;\n          d.parts.forEach(function (f) {\n            var k = {\n              \"class\": \"highcharts-3d-\" + f,\n              zIndex: a[f] || 0\n            };\n            c.styledMode && (\"top\" === f ? k.filter = \"url(#highcharts-brighter)\" : \"side\" === f && (k.filter = \"url(#highcharts-darker)\"));\n            d[f] = c.path(b[f]).attr(k).add(d);\n          });\n          d.attr({\n            \"stroke-linejoin\": \"round\",\n            zIndex: a.group\n          });\n          d.originalDestroy = d.destroy;\n          d.destroy = d.destroyParts;\n          d.forcedSides = b.forcedSides;\n        },\n        singleSetterForParts: function (f, d, c, b, a, q) {\n          var k = {};\n          b = [null, null, b || \"attr\", a, q];\n          var e = c && c.zIndexes;\n          c ? (e && e.group && this.attr({\n            zIndex: e.group\n          }), z(c, function (b, d) {\n            k[d] = {};\n            k[d][f] = b;\n            e && (k[d].zIndex = c.zIndexes[d] || 0);\n          }), b[1] = k) : (k[f] = d, b[0] = k);\n          return this.processParts.apply(this, b);\n        },\n        processParts: function (f, d, c, b, a) {\n          var k = this;\n          k.parts.forEach(function (q) {\n            d && (f = v(d[q], !1));\n            if (!1 !== f) k[q][c](f, b, a);\n          });\n          return k;\n        },\n        destroyParts: function () {\n          this.processParts(null, null, \"destroy\");\n          return this.originalDestroy();\n        }\n      }\n    };\n    x.cuboid = a(x.base, {\n      parts: [\"front\", \"top\", \"side\"],\n      pathType: \"cuboid\",\n      attr: function (a, d, c, b) {\n        if (\"string\" === typeof a && \"undefined\" !== typeof d) {\n          var k = a;\n          a = {};\n          a[k] = d;\n        }\n\n        return a.shapeArgs || f(a.x) ? this.singleSetterForParts(\"d\", null, this.renderer[this.pathType + \"Path\"](a.shapeArgs || a)) : w.prototype.attr.call(this, a, void 0, c, b);\n      },\n      animate: function (a, d, c) {\n        if (f(a.x) && f(a.y)) {\n          a = this.renderer[this.pathType + \"Path\"](a);\n          var b = a.forcedSides;\n          this.singleSetterForParts(\"d\", null, a, \"animate\", d, c);\n          this.attr({\n            zIndex: a.zIndexes.group\n          });\n          b !== this.forcedSides && (this.forcedSides = b, this.renderer.styledMode || x.cuboid.fillSetter.call(this, this.fill));\n        } else w.prototype.animate.call(this, a, d, c);\n\n        return this;\n      },\n      fillSetter: function (a) {\n        this.forcedSides = this.forcedSides || [];\n        this.singleSetterForParts(\"fill\", null, {\n          front: a,\n          top: F(a).brighten(0 <= this.forcedSides.indexOf(\"top\") ? 0 : .1).get(),\n          side: F(a).brighten(0 <= this.forcedSides.indexOf(\"side\") ? 0 : -.1).get()\n        });\n        this.color = this.fill = a;\n        return this;\n      }\n    });\n    return x;\n  });\n  E(a, \"Core/Renderer/SVG/SVGRenderer3D.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Extensions/Math3D.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGElement3D.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D, f, z, v, x) {\n    var k = this && this.__extends || function () {\n      var b = function (e, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, h) {\n          b.__proto__ = h;\n        } || function (b, h) {\n          for (var r in h) h.hasOwnProperty(r) && (b[r] = h[r]);\n        };\n\n        return b(e, c);\n      };\n\n      return function (e, c) {\n        function d() {\n          this.constructor = e;\n        }\n\n        b(e, c);\n        e.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }(),\n        d = a.animObject,\n        c = w.parse,\n        b = t.charts,\n        l = t.deg2rad,\n        q = D.perspective,\n        A = D.shapeArea,\n        e = x.defined,\n        n = x.extend,\n        u = x.merge,\n        p = x.pick,\n        G = Math.cos,\n        C = Math.sin,\n        I = Math.PI,\n        B = 4 * (Math.sqrt(2) - 1) / 3 / (I / 2);\n\n    return function (a) {\n      function m() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      k(m, a);\n\n      m.compose = function (b) {\n        b = b.prototype;\n        var e = m.prototype;\n        b.elements3d = z;\n        b.arc3d = e.arc3d;\n        b.arc3dPath = e.arc3dPath;\n        b.cuboid = e.cuboid;\n        b.cuboidPath = e.cuboidPath;\n        b.element3d = e.element3d;\n        b.face3d = e.face3d;\n        b.polyhedron = e.polyhedron;\n        b.toLinePath = e.toLinePath;\n        b.toLineSegments = e.toLineSegments;\n      };\n\n      m.curveTo = function (b, e, h, r, g, y, c, d) {\n        var H = [],\n            a = y - g;\n        return y > g && y - g > Math.PI / 2 + .0001 ? (H = H.concat(this.curveTo(b, e, h, r, g, g + Math.PI / 2, c, d)), H = H.concat(this.curveTo(b, e, h, r, g + Math.PI / 2, y, c, d))) : y < g && g - y > Math.PI / 2 + .0001 ? (H = H.concat(this.curveTo(b, e, h, r, g, g - Math.PI / 2, c, d)), H = H.concat(this.curveTo(b, e, h, r, g - Math.PI / 2, y, c, d))) : [[\"C\", b + h * Math.cos(g) - h * B * a * Math.sin(g) + c, e + r * Math.sin(g) + r * B * a * Math.cos(g) + d, b + h * Math.cos(y) + h * B * a * Math.sin(y) + c, e + r * Math.sin(y) - r * B * a * Math.cos(y) + d, b + h * Math.cos(y) + c, e + r * Math.sin(y) + d]];\n      };\n\n      m.prototype.toLinePath = function (b, e) {\n        var h = [];\n        b.forEach(function (b) {\n          h.push([\"L\", b.x, b.y]);\n        });\n        b.length && (h[0][0] = \"M\", e && h.push([\"Z\"]));\n        return h;\n      };\n\n      m.prototype.toLineSegments = function (b) {\n        var e = [],\n            h = !0;\n        b.forEach(function (b) {\n          e.push(h ? [\"M\", b.x, b.y] : [\"L\", b.x, b.y]);\n          h = !h;\n        });\n        return e;\n      };\n\n      m.prototype.face3d = function (c) {\n        var d = this,\n            h = this.createElement(\"path\");\n        h.vertexes = [];\n        h.insidePlotArea = !1;\n        h.enabled = !0;\n\n        h.attr = function (h) {\n          if (\"object\" === typeof h && (e(h.enabled) || e(h.vertexes) || e(h.insidePlotArea))) {\n            this.enabled = p(h.enabled, this.enabled);\n            this.vertexes = p(h.vertexes, this.vertexes);\n            this.insidePlotArea = p(h.insidePlotArea, this.insidePlotArea);\n            delete h.enabled;\n            delete h.vertexes;\n            delete h.insidePlotArea;\n            var g = q(this.vertexes, b[d.chartIndex], this.insidePlotArea),\n                y = d.toLinePath(g, !0);\n            g = A(g);\n            h.d = y;\n            h.visibility = this.enabled && 0 < g ? \"visible\" : \"hidden\";\n          }\n\n          return f.prototype.attr.apply(this, arguments);\n        };\n\n        h.animate = function (h) {\n          if (\"object\" === typeof h && (e(h.enabled) || e(h.vertexes) || e(h.insidePlotArea))) {\n            this.enabled = p(h.enabled, this.enabled);\n            this.vertexes = p(h.vertexes, this.vertexes);\n            this.insidePlotArea = p(h.insidePlotArea, this.insidePlotArea);\n            delete h.enabled;\n            delete h.vertexes;\n            delete h.insidePlotArea;\n            var g = q(this.vertexes, b[d.chartIndex], this.insidePlotArea),\n                y = d.toLinePath(g, !0);\n            g = A(g);\n            g = this.enabled && 0 < g ? \"visible\" : \"hidden\";\n            h.d = y;\n            this.attr(\"visibility\", g);\n          }\n\n          return f.prototype.animate.apply(this, arguments);\n        };\n\n        return h.attr(c);\n      };\n\n      m.prototype.polyhedron = function (b) {\n        var c = this,\n            h = this.g(),\n            r = h.destroy;\n        this.styledMode || h.attr({\n          \"stroke-linejoin\": \"round\"\n        });\n        h.faces = [];\n\n        h.destroy = function () {\n          for (var b = 0; b < h.faces.length; b++) h.faces[b].destroy();\n\n          return r.call(this);\n        };\n\n        h.attr = function (b, y, r, d) {\n          if (\"object\" === typeof b && e(b.faces)) {\n            for (; h.faces.length > b.faces.length;) h.faces.pop().destroy();\n\n            for (; h.faces.length < b.faces.length;) h.faces.push(c.face3d().add(h));\n\n            for (var g = 0; g < b.faces.length; g++) c.styledMode && delete b.faces[g].fill, h.faces[g].attr(b.faces[g], null, r, d);\n\n            delete b.faces;\n          }\n\n          return f.prototype.attr.apply(this, arguments);\n        };\n\n        h.animate = function (b, e, r) {\n          if (b && b.faces) {\n            for (; h.faces.length > b.faces.length;) h.faces.pop().destroy();\n\n            for (; h.faces.length < b.faces.length;) h.faces.push(c.face3d().add(h));\n\n            for (var g = 0; g < b.faces.length; g++) h.faces[g].animate(b.faces[g], e, r);\n\n            delete b.faces;\n          }\n\n          return f.prototype.animate.apply(this, arguments);\n        };\n\n        return h.attr(b);\n      };\n\n      m.prototype.element3d = function (b, e) {\n        var h = this.g();\n        n(h, this.elements3d[b]);\n        h.initArgs(e);\n        return h;\n      };\n\n      m.prototype.cuboid = function (b) {\n        return this.element3d(\"cuboid\", b);\n      };\n\n      m.prototype.cuboidPath = function (e) {\n        function c(b) {\n          return 0 === d && 1 < b && 6 > b ? {\n            x: m[b].x,\n            y: m[b].y + 10,\n            z: m[b].z\n          } : m[0].x === m[7].x && 4 <= b ? {\n            x: m[b].x + 10,\n            y: m[b].y,\n            z: m[b].z\n          } : 0 === n && 2 > b || 5 < b ? {\n            x: m[b].x,\n            y: m[b].y,\n            z: m[b].z + 10\n          } : m[b];\n        }\n\n        function h(b) {\n          return m[b];\n        }\n\n        var r = e.x || 0,\n            g = e.y || 0,\n            y = e.z || 0,\n            d = e.height || 0,\n            a = e.width || 0,\n            n = e.depth || 0,\n            f = b[this.chartIndex],\n            p = f.options.chart.options3d.alpha,\n            u = 0,\n            m = [{\n          x: r,\n          y: g,\n          z: y\n        }, {\n          x: r + a,\n          y: g,\n          z: y\n        }, {\n          x: r + a,\n          y: g + d,\n          z: y\n        }, {\n          x: r,\n          y: g + d,\n          z: y\n        }, {\n          x: r,\n          y: g + d,\n          z: y + n\n        }, {\n          x: r + a,\n          y: g + d,\n          z: y + n\n        }, {\n          x: r + a,\n          y: g,\n          z: y + n\n        }, {\n          x: r,\n          y: g,\n          z: y + n\n        }],\n            C = [];\n        m = q(m, f, e.insidePlotArea);\n\n        var J = function (b, g, e) {\n          var y = [[], -1],\n              r = b.map(h),\n              d = g.map(h);\n          b = b.map(c);\n          g = g.map(c);\n          0 > A(r) ? y = [r, 0] : 0 > A(d) ? y = [d, 1] : e && (C.push(e), y = 0 > A(b) ? [r, 0] : 0 > A(g) ? [d, 1] : [r, 0]);\n          return y;\n        };\n\n        var l = J([3, 2, 1, 0], [7, 6, 5, 4], \"front\");\n        e = l[0];\n        var G = l[1];\n        l = J([1, 6, 7, 0], [4, 5, 2, 3], \"top\");\n        a = l[0];\n        var k = l[1];\n        l = J([1, 2, 5, 6], [0, 7, 4, 3], \"side\");\n        J = l[0];\n        l = l[1];\n        1 === l ? u += 1E6 * (f.plotWidth - r) : l || (u += 1E6 * r);\n        u += 10 * (!k || 0 <= p && 180 >= p || 360 > p && 357.5 < p ? f.plotHeight - g : 10 + g);\n        1 === G ? u += 100 * y : G || (u += 100 * (1E3 - y));\n        return {\n          front: this.toLinePath(e, !0),\n          top: this.toLinePath(a, !0),\n          side: this.toLinePath(J, !0),\n          zIndexes: {\n            group: Math.round(u)\n          },\n          forcedSides: C,\n          isFront: G,\n          isTop: k\n        };\n      };\n\n      m.prototype.arc3d = function (b) {\n        function e(b) {\n          var h = !1,\n              e = {},\n              y;\n          b = u(b);\n\n          for (y in b) -1 !== g.indexOf(y) && (e[y] = b[y], delete b[y], h = !0);\n\n          return h ? [e, b] : !1;\n        }\n\n        var h = this.g(),\n            r = h.renderer,\n            g = \"x y r innerR start end depth\".split(\" \");\n        b = u(b);\n        b.alpha = (b.alpha || 0) * l;\n        b.beta = (b.beta || 0) * l;\n        h.top = r.path();\n        h.side1 = r.path();\n        h.side2 = r.path();\n        h.inn = r.path();\n        h.out = r.path();\n\n        h.onAdd = function () {\n          var b = h.parentGroup,\n              e = h.attr(\"class\");\n          h.top.add(h);\n          [\"out\", \"inn\", \"side1\", \"side2\"].forEach(function (g) {\n            h[g].attr({\n              \"class\": e + \" highcharts-3d-side\"\n            }).add(b);\n          });\n        };\n\n        [\"addClass\", \"removeClass\"].forEach(function (b) {\n          h[b] = function () {\n            var e = arguments;\n            [\"top\", \"out\", \"inn\", \"side1\", \"side2\"].forEach(function (g) {\n              h[g][b].apply(h[g], e);\n            });\n          };\n        });\n\n        h.setPaths = function (b) {\n          var e = h.renderer.arc3dPath(b),\n              g = 100 * e.zTop;\n          h.attribs = b;\n          h.top.attr({\n            d: e.top,\n            zIndex: e.zTop\n          });\n          h.inn.attr({\n            d: e.inn,\n            zIndex: e.zInn\n          });\n          h.out.attr({\n            d: e.out,\n            zIndex: e.zOut\n          });\n          h.side1.attr({\n            d: e.side1,\n            zIndex: e.zSide1\n          });\n          h.side2.attr({\n            d: e.side2,\n            zIndex: e.zSide2\n          });\n          h.zIndex = g;\n          h.attr({\n            zIndex: g\n          });\n          b.center && (h.top.setRadialReference(b.center), delete b.center);\n        };\n\n        h.setPaths(b);\n\n        h.fillSetter = function (b) {\n          var e = c(b).brighten(-.1).get();\n          this.fill = b;\n          this.side1.attr({\n            fill: e\n          });\n          this.side2.attr({\n            fill: e\n          });\n          this.inn.attr({\n            fill: e\n          });\n          this.out.attr({\n            fill: e\n          });\n          this.top.attr({\n            fill: b\n          });\n          return this;\n        };\n\n        [\"opacity\", \"translateX\", \"translateY\", \"visibility\"].forEach(function (b) {\n          h[b + \"Setter\"] = function (b, e) {\n            h[e] = b;\n            [\"out\", \"inn\", \"side1\", \"side2\", \"top\"].forEach(function (g) {\n              h[g].attr(e, b);\n            });\n          };\n        });\n\n        h.attr = function (b) {\n          var g;\n\n          if (\"object\" === typeof b && (g = e(b))) {\n            var y = g[0];\n            arguments[0] = g[1];\n            n(h.attribs, y);\n            h.setPaths(h.attribs);\n          }\n\n          return f.prototype.attr.apply(h, arguments);\n        };\n\n        h.animate = function (b, g, r) {\n          var y = this.attribs,\n              c = \"data-\" + Math.random().toString(26).substring(2, 9);\n          delete b.center;\n          delete b.z;\n          delete b.alpha;\n          delete b.beta;\n          var a = d(p(g, this.renderer.globalAnimation));\n\n          if (a.duration) {\n            g = e(b);\n            h[c] = 0;\n            b[c] = 1;\n            h[c + \"Setter\"] = t.noop;\n\n            if (g) {\n              var n = g[0];\n\n              a.step = function (b, e) {\n                function g(b) {\n                  return y[b] + (p(n[b], y[b]) - y[b]) * e.pos;\n                }\n\n                e.prop === c && e.elem.setPaths(u(y, {\n                  x: g(\"x\"),\n                  y: g(\"y\"),\n                  r: g(\"r\"),\n                  innerR: g(\"innerR\"),\n                  start: g(\"start\"),\n                  end: g(\"end\"),\n                  depth: g(\"depth\")\n                }));\n              };\n            }\n\n            g = a;\n          }\n\n          return f.prototype.animate.call(this, b, g, r);\n        };\n\n        h.destroy = function () {\n          this.top.destroy();\n          this.out.destroy();\n          this.inn.destroy();\n          this.side1.destroy();\n          this.side2.destroy();\n          return f.prototype.destroy.call(this);\n        };\n\n        h.hide = function () {\n          this.top.hide();\n          this.out.hide();\n          this.inn.hide();\n          this.side1.hide();\n          this.side2.hide();\n        };\n\n        h.show = function (b) {\n          this.top.show(b);\n          this.out.show(b);\n          this.inn.show(b);\n          this.side1.show(b);\n          this.side2.show(b);\n        };\n\n        return h;\n      };\n\n      m.prototype.arc3dPath = function (b) {\n        function e(b) {\n          b %= 2 * Math.PI;\n          b > Math.PI && (b = 2 * Math.PI - b);\n          return b;\n        }\n\n        var h = b.x || 0,\n            r = b.y || 0,\n            g = b.start || 0,\n            c = (b.end || 0) - .00001,\n            d = b.r || 0,\n            a = b.innerR || 0,\n            n = b.depth || 0,\n            f = b.alpha || 0,\n            p = b.beta || 0,\n            u = Math.cos(g),\n            l = Math.sin(g);\n        b = Math.cos(c);\n        var q = Math.sin(c),\n            k = d * Math.cos(p);\n        d *= Math.cos(f);\n        var A = a * Math.cos(p),\n            v = a * Math.cos(f);\n        a = n * Math.sin(p);\n        var B = n * Math.sin(f);\n        n = [[\"M\", h + k * u, r + d * l]];\n        n = n.concat(m.curveTo(h, r, k, d, g, c, 0, 0));\n        n.push([\"L\", h + A * b, r + v * q]);\n        n = n.concat(m.curveTo(h, r, A, v, c, g, 0, 0));\n        n.push([\"Z\"]);\n        var z = 0 < p ? Math.PI / 2 : 0;\n        p = 0 < f ? 0 : Math.PI / 2;\n        z = g > -z ? g : c > -z ? -z : g;\n        var t = c < I - p ? c : g < I - p ? I - p : c,\n            x = 2 * I - p;\n        f = [[\"M\", h + k * G(z), r + d * C(z)]];\n        f = f.concat(m.curveTo(h, r, k, d, z, t, 0, 0));\n        c > x && g < x ? (f.push([\"L\", h + k * G(t) + a, r + d * C(t) + B]), f = f.concat(m.curveTo(h, r, k, d, t, x, a, B)), f.push([\"L\", h + k * G(x), r + d * C(x)]), f = f.concat(m.curveTo(h, r, k, d, x, c, 0, 0)), f.push([\"L\", h + k * G(c) + a, r + d * C(c) + B]), f = f.concat(m.curveTo(h, r, k, d, c, x, a, B)), f.push([\"L\", h + k * G(x), r + d * C(x)]), f = f.concat(m.curveTo(h, r, k, d, x, t, 0, 0))) : c > I - p && g < I - p && (f.push([\"L\", h + k * Math.cos(t) + a, r + d * Math.sin(t) + B]), f = f.concat(m.curveTo(h, r, k, d, t, c, a, B)), f.push([\"L\", h + k * Math.cos(c), r + d * Math.sin(c)]), f = f.concat(m.curveTo(h, r, k, d, c, t, 0, 0)));\n        f.push([\"L\", h + k * Math.cos(t) + a, r + d * Math.sin(t) + B]);\n        f = f.concat(m.curveTo(h, r, k, d, t, z, a, B));\n        f.push([\"Z\"]);\n        p = [[\"M\", h + A * u, r + v * l]];\n        p = p.concat(m.curveTo(h, r, A, v, g, c, 0, 0));\n        p.push([\"L\", h + A * Math.cos(c) + a, r + v * Math.sin(c) + B]);\n        p = p.concat(m.curveTo(h, r, A, v, c, g, a, B));\n        p.push([\"Z\"]);\n        u = [[\"M\", h + k * u, r + d * l], [\"L\", h + k * u + a, r + d * l + B], [\"L\", h + A * u + a, r + v * l + B], [\"L\", h + A * u, r + v * l], [\"Z\"]];\n        h = [[\"M\", h + k * b, r + d * q], [\"L\", h + k * b + a, r + d * q + B], [\"L\", h + A * b + a, r + v * q + B], [\"L\", h + A * b, r + v * q], [\"Z\"]];\n        q = Math.atan2(B, -a);\n        r = Math.abs(c + q);\n        b = Math.abs(g + q);\n        g = Math.abs((g + c) / 2 + q);\n        r = e(r);\n        b = e(b);\n        g = e(g);\n        g *= 1E5;\n        c = 1E5 * b;\n        r *= 1E5;\n        return {\n          top: n,\n          zTop: 1E5 * Math.PI + 1,\n          out: f,\n          zOut: Math.max(g, c, r),\n          inn: p,\n          zInn: Math.max(g, c, r),\n          side1: u,\n          zSide1: .99 * r,\n          side2: h,\n          zSide2: .99 * c\n        };\n      };\n\n      return m;\n    }(v);\n  });\n  E(a, \"Core/Chart/Chart3D.js\", [a[\"Core/Color/Color.js\"], a[\"Extensions/Math3D.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D) {\n    var f = a.parse,\n        z = w.perspective,\n        v = w.shapeArea3D,\n        x = t.defaultOptions,\n        k = D.addEvent,\n        d = D.isArray,\n        c = D.merge,\n        b = D.pick,\n        l = D.wrap,\n        q;\n\n    (function (a) {\n      function e(b) {\n        this.is3d() && \"scatter\" === b.options.type && (b.options.type = \"scatter3d\");\n      }\n\n      function n() {\n        if (this.chart3d && this.is3d()) {\n          var b = this.renderer,\n              e = this.options.chart.options3d,\n              g = this.chart3d.get3dFrame(),\n              c = this.plotLeft,\n              d = this.plotLeft + this.plotWidth,\n              a = this.plotTop,\n              p = this.plotTop + this.plotHeight;\n          e = e.depth;\n          var n = c - (g.left.visible ? g.left.size : 0),\n              u = d + (g.right.visible ? g.right.size : 0),\n              m = a - (g.top.visible ? g.top.size : 0),\n              k = p + (g.bottom.visible ? g.bottom.size : 0),\n              q = 0 - (g.front.visible ? g.front.size : 0),\n              l = e + (g.back.visible ? g.back.size : 0),\n              C = this.hasRendered ? \"animate\" : \"attr\";\n          this.chart3d.frame3d = g;\n          this.frameShapes || (this.frameShapes = {\n            bottom: b.polyhedron().add(),\n            top: b.polyhedron().add(),\n            left: b.polyhedron().add(),\n            right: b.polyhedron().add(),\n            back: b.polyhedron().add(),\n            front: b.polyhedron().add()\n          });\n          this.frameShapes.bottom[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-bottom\",\n            zIndex: g.bottom.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: n,\n                y: k,\n                z: l\n              }],\n              enabled: g.bottom.visible\n            }, {\n              fill: f(g.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }],\n              enabled: g.bottom.visible\n            }, {\n              fill: f(g.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }],\n              enabled: g.bottom.visible && !g.left.visible\n            }, {\n              fill: f(g.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }],\n              enabled: g.bottom.visible && !g.right.visible\n            }, {\n              fill: f(g.bottom.color).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }],\n              enabled: g.bottom.visible && !g.front.visible\n            }, {\n              fill: f(g.bottom.color).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }],\n              enabled: g.bottom.visible && !g.back.visible\n            }]\n          });\n          this.frameShapes.top[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-top\",\n            zIndex: g.top.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }],\n              enabled: g.top.visible\n            }, {\n              fill: f(g.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }],\n              enabled: g.top.visible\n            }, {\n              fill: f(g.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }],\n              enabled: g.top.visible && !g.left.visible\n            }, {\n              fill: f(g.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }],\n              enabled: g.top.visible && !g.right.visible\n            }, {\n              fill: f(g.top.color).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }],\n              enabled: g.top.visible && !g.front.visible\n            }, {\n              fill: f(g.top.color).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }],\n              enabled: g.top.visible && !g.back.visible\n            }]\n          });\n          this.frameShapes.left[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-left\",\n            zIndex: g.left.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: n,\n                y: k,\n                z: l\n              }],\n              enabled: g.left.visible && !g.bottom.visible\n            }, {\n              fill: f(g.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }],\n              enabled: g.left.visible && !g.top.visible\n            }, {\n              fill: f(g.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: n,\n                y: k,\n                z: q\n              }],\n              enabled: g.left.visible\n            }, {\n              fill: f(g.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: c,\n                y: a,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }],\n              enabled: g.left.visible\n            }, {\n              fill: f(g.left.color).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }],\n              enabled: g.left.visible && !g.front.visible\n            }, {\n              fill: f(g.left.color).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }],\n              enabled: g.left.visible && !g.back.visible\n            }]\n          });\n          this.frameShapes.right[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-right\",\n            zIndex: g.right.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: u,\n                y: k,\n                z: q\n              }],\n              enabled: g.right.visible && !g.bottom.visible\n            }, {\n              fill: f(g.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }],\n              enabled: g.right.visible && !g.top.visible\n            }, {\n              fill: f(g.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }],\n              enabled: g.right.visible\n            }, {\n              fill: f(g.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: u,\n                y: k,\n                z: l\n              }],\n              enabled: g.right.visible\n            }, {\n              fill: f(g.right.color).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }],\n              enabled: g.right.visible && !g.front.visible\n            }, {\n              fill: f(g.right.color).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }],\n              enabled: g.right.visible && !g.back.visible\n            }]\n          });\n          this.frameShapes.back[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-back\",\n            zIndex: g.back.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }],\n              enabled: g.back.visible && !g.bottom.visible\n            }, {\n              fill: f(g.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }],\n              enabled: g.back.visible && !g.top.visible\n            }, {\n              fill: f(g.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: l\n              }, {\n                x: c,\n                y: a,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }],\n              enabled: g.back.visible && !g.left.visible\n            }, {\n              fill: f(g.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }],\n              enabled: g.back.visible && !g.right.visible\n            }, {\n              fill: f(g.back.color).get(),\n              vertexes: [{\n                x: c,\n                y: a,\n                z: e\n              }, {\n                x: d,\n                y: a,\n                z: e\n              }, {\n                x: d,\n                y: p,\n                z: e\n              }, {\n                x: c,\n                y: p,\n                z: e\n              }],\n              enabled: g.back.visible\n            }, {\n              fill: f(g.back.color).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: l\n              }, {\n                x: u,\n                y: k,\n                z: l\n              }, {\n                x: u,\n                y: m,\n                z: l\n              }, {\n                x: n,\n                y: m,\n                z: l\n              }],\n              enabled: g.back.visible\n            }]\n          });\n          this.frameShapes.front[C]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-front\",\n            zIndex: g.front.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: f(g.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }],\n              enabled: g.front.visible && !g.bottom.visible\n            }, {\n              fill: f(g.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }],\n              enabled: g.front.visible && !g.top.visible\n            }, {\n              fill: f(g.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }],\n              enabled: g.front.visible && !g.left.visible\n            }, {\n              fill: f(g.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: q\n              }, {\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }],\n              enabled: g.front.visible && !g.right.visible\n            }, {\n              fill: f(g.front.color).get(),\n              vertexes: [{\n                x: d,\n                y: a,\n                z: 0\n              }, {\n                x: c,\n                y: a,\n                z: 0\n              }, {\n                x: c,\n                y: p,\n                z: 0\n              }, {\n                x: d,\n                y: p,\n                z: 0\n              }],\n              enabled: g.front.visible\n            }, {\n              fill: f(g.front.color).get(),\n              vertexes: [{\n                x: u,\n                y: k,\n                z: q\n              }, {\n                x: n,\n                y: k,\n                z: q\n              }, {\n                x: n,\n                y: m,\n                z: q\n              }, {\n                x: u,\n                y: m,\n                z: q\n              }],\n              enabled: g.front.visible\n            }]\n          });\n        }\n      }\n\n      function u() {\n        this.styledMode && [{\n          name: \"darker\",\n          slope: .6\n        }, {\n          name: \"brighter\",\n          slope: 1.4\n        }].forEach(function (b) {\n          this.renderer.definition({\n            tagName: \"filter\",\n            attributes: {\n              id: \"highcharts-\" + b.name\n            },\n            children: [{\n              tagName: \"feComponentTransfer\",\n              children: [{\n                tagName: \"feFuncR\",\n                attributes: {\n                  type: \"linear\",\n                  slope: b.slope\n                }\n              }, {\n                tagName: \"feFuncG\",\n                attributes: {\n                  type: \"linear\",\n                  slope: b.slope\n                }\n              }, {\n                tagName: \"feFuncB\",\n                attributes: {\n                  type: \"linear\",\n                  slope: b.slope\n                }\n              }]\n            }]\n          });\n        }, this);\n      }\n\n      function p() {\n        var b = this.options;\n        this.is3d() && (b.series || []).forEach(function (e) {\n          \"scatter\" === (e.type || b.chart.type || b.chart.defaultSeriesType) && (e.type = \"scatter3d\");\n        });\n      }\n\n      function q() {\n        var b = this.options.chart.options3d;\n\n        if (this.chart3d && this.is3d()) {\n          b && (b.alpha = b.alpha % 360 + (0 <= b.alpha ? 0 : 360), b.beta = b.beta % 360 + (0 <= b.beta ? 0 : 360));\n          var e = this.inverted,\n              g = this.clipBox,\n              c = this.margin;\n          g[e ? \"y\" : \"x\"] = -(c[3] || 0);\n          g[e ? \"x\" : \"y\"] = -(c[0] || 0);\n          g[e ? \"height\" : \"width\"] = this.chartWidth + (c[3] || 0) + (c[1] || 0);\n          g[e ? \"width\" : \"height\"] = this.chartHeight + (c[0] || 0) + (c[2] || 0);\n          this.scale3d = 1;\n          !0 === b.fitToPlot && (this.scale3d = this.chart3d.getScale(b.depth));\n          this.chart3d.frame3d = this.chart3d.get3dFrame();\n        }\n      }\n\n      function C() {\n        this.is3d() && (this.isDirtyBox = !0);\n      }\n\n      function A() {\n        this.chart3d && this.is3d() && (this.chart3d.frame3d = this.chart3d.get3dFrame());\n      }\n\n      function B() {\n        this.chart3d || (this.chart3d = new F(this));\n      }\n\n      function m(b) {\n        return this.is3d() || b.apply(this, [].slice.call(arguments, 1));\n      }\n\n      function t(b) {\n        var e = this.series.length;\n        if (this.is3d()) for (; e--;) b = this.series[e], b.translate(), b.render();else b.call(this);\n      }\n\n      function w(b) {\n        b.apply(this, [].slice.call(arguments, 1));\n        this.is3d() && (this.container.className += \" highcharts-3d-chart\");\n      }\n\n      var F = function () {\n        function e(b) {\n          this.frame3d = void 0;\n          this.chart = b;\n        }\n\n        e.prototype.get3dFrame = function () {\n          var e = this.chart,\n              g = e.options.chart.options3d,\n              c = g.frame,\n              d = e.plotLeft,\n              a = e.plotLeft + e.plotWidth,\n              h = e.plotTop,\n              p = e.plotTop + e.plotHeight,\n              n = g.depth,\n              f = function (b) {\n            b = v(b, e);\n            return .5 < b ? 1 : -.5 > b ? -1 : 0;\n          },\n              u = f([{\n            x: d,\n            y: p,\n            z: n\n          }, {\n            x: a,\n            y: p,\n            z: n\n          }, {\n            x: a,\n            y: p,\n            z: 0\n          }, {\n            x: d,\n            y: p,\n            z: 0\n          }]),\n              m = f([{\n            x: d,\n            y: h,\n            z: 0\n          }, {\n            x: a,\n            y: h,\n            z: 0\n          }, {\n            x: a,\n            y: h,\n            z: n\n          }, {\n            x: d,\n            y: h,\n            z: n\n          }]),\n              k = f([{\n            x: d,\n            y: h,\n            z: 0\n          }, {\n            x: d,\n            y: h,\n            z: n\n          }, {\n            x: d,\n            y: p,\n            z: n\n          }, {\n            x: d,\n            y: p,\n            z: 0\n          }]),\n              q = f([{\n            x: a,\n            y: h,\n            z: n\n          }, {\n            x: a,\n            y: h,\n            z: 0\n          }, {\n            x: a,\n            y: p,\n            z: 0\n          }, {\n            x: a,\n            y: p,\n            z: n\n          }]),\n              l = f([{\n            x: d,\n            y: p,\n            z: 0\n          }, {\n            x: a,\n            y: p,\n            z: 0\n          }, {\n            x: a,\n            y: h,\n            z: 0\n          }, {\n            x: d,\n            y: h,\n            z: 0\n          }]);\n\n          f = f([{\n            x: d,\n            y: h,\n            z: n\n          }, {\n            x: a,\n            y: h,\n            z: n\n          }, {\n            x: a,\n            y: p,\n            z: n\n          }, {\n            x: d,\n            y: p,\n            z: n\n          }]);\n          var C = !1,\n              G = !1,\n              B = !1,\n              A = !1;\n          [].concat(e.xAxis, e.yAxis, e.zAxis).forEach(function (b) {\n            b && (b.horiz ? b.opposite ? G = !0 : C = !0 : b.opposite ? A = !0 : B = !0);\n          });\n\n          var t = function (e, c, d) {\n            for (var g = [\"size\", \"color\", \"visible\"], a = {}, p = 0; p < g.length; p++) for (var h = g[p], n = 0; n < e.length; n++) if (\"object\" === typeof e[n]) {\n              var f = e[n][h];\n\n              if (\"undefined\" !== typeof f && null !== f) {\n                a[h] = f;\n                break;\n              }\n            }\n\n            e = d;\n            !0 === a.visible || !1 === a.visible ? e = a.visible : \"auto\" === a.visible && (e = 0 < c);\n            return {\n              size: b(a.size, 1),\n              color: b(a.color, \"none\"),\n              frontFacing: 0 < c,\n              visible: e\n            };\n          };\n\n          c = {\n            axes: {},\n            bottom: t([c.bottom, c.top, c], u, C),\n            top: t([c.top, c.bottom, c], m, G),\n            left: t([c.left, c.right, c.side, c], k, B),\n            right: t([c.right, c.left, c.side, c], q, A),\n            back: t([c.back, c.front, c], f, !0),\n            front: t([c.front, c.back, c], l, !1)\n          };\n          \"auto\" === g.axisLabelPosition ? (q = function (b, e) {\n            return b.visible !== e.visible || b.visible && e.visible && b.frontFacing !== e.frontFacing;\n          }, g = [], q(c.left, c.front) && g.push({\n            y: (h + p) / 2,\n            x: d,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), q(c.left, c.back) && g.push({\n            y: (h + p) / 2,\n            x: d,\n            z: n,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), q(c.right, c.front) && g.push({\n            y: (h + p) / 2,\n            x: a,\n            z: 0,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), q(c.right, c.back) && g.push({\n            y: (h + p) / 2,\n            x: a,\n            z: n,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), u = [], q(c.bottom, c.front) && u.push({\n            x: (d + a) / 2,\n            y: p,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), q(c.bottom, c.back) && u.push({\n            x: (d + a) / 2,\n            y: p,\n            z: n,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), m = [], q(c.top, c.front) && m.push({\n            x: (d + a) / 2,\n            y: h,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), q(c.top, c.back) && m.push({\n            x: (d + a) / 2,\n            y: h,\n            z: n,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), k = [], q(c.bottom, c.left) && k.push({\n            z: (0 + n) / 2,\n            y: p,\n            x: d,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), q(c.bottom, c.right) && k.push({\n            z: (0 + n) / 2,\n            y: p,\n            x: a,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), p = [], q(c.top, c.left) && p.push({\n            z: (0 + n) / 2,\n            y: h,\n            x: d,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), q(c.top, c.right) && p.push({\n            z: (0 + n) / 2,\n            y: h,\n            x: a,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), d = function (b, c, d) {\n            if (0 === b.length) return null;\n            if (1 === b.length) return b[0];\n\n            for (var g = z(b, e, !1), a = 0, p = 1; p < g.length; p++) d * g[p][c] > d * g[a][c] ? a = p : d * g[p][c] === d * g[a][c] && g[p].z < g[a].z && (a = p);\n\n            return b[a];\n          }, c.axes = {\n            y: {\n              left: d(g, \"x\", -1),\n              right: d(g, \"x\", 1)\n            },\n            x: {\n              top: d(m, \"y\", -1),\n              bottom: d(u, \"y\", 1)\n            },\n            z: {\n              top: d(p, \"y\", -1),\n              bottom: d(k, \"y\", 1)\n            }\n          }) : c.axes = {\n            y: {\n              left: {\n                x: d,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              right: {\n                x: a,\n                z: 0,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              }\n            },\n            x: {\n              top: {\n                y: h,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              bottom: {\n                y: p,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              }\n            },\n            z: {\n              top: {\n                x: B ? a : d,\n                y: h,\n                xDir: B ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              },\n              bottom: {\n                x: B ? a : d,\n                y: p,\n                xDir: B ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              }\n            }\n          };\n          return c;\n        };\n\n        e.prototype.getScale = function (b) {\n          var e = this.chart,\n              c = e.plotLeft,\n              d = e.plotWidth + c,\n              a = e.plotTop,\n              p = e.plotHeight + a,\n              h = c + e.plotWidth / 2,\n              n = a + e.plotHeight / 2,\n              f = Number.MAX_VALUE,\n              u = -Number.MAX_VALUE,\n              m = Number.MAX_VALUE,\n              q = -Number.MAX_VALUE,\n              k = 1;\n          var l = [{\n            x: c,\n            y: a,\n            z: 0\n          }, {\n            x: c,\n            y: a,\n            z: b\n          }];\n          [0, 1].forEach(function (b) {\n            l.push({\n              x: d,\n              y: l[b].y,\n              z: l[b].z\n            });\n          });\n          [0, 1, 2, 3].forEach(function (b) {\n            l.push({\n              x: l[b].x,\n              y: p,\n              z: l[b].z\n            });\n          });\n          l = z(l, e, !1);\n          l.forEach(function (b) {\n            f = Math.min(f, b.x);\n            u = Math.max(u, b.x);\n            m = Math.min(m, b.y);\n            q = Math.max(q, b.y);\n          });\n          c > f && (k = Math.min(k, 1 - Math.abs((c + h) / (f + h)) % 1));\n          d < u && (k = Math.min(k, (d - h) / (u - h)));\n          a > m && (k = 0 > m ? Math.min(k, (a + n) / (-m + a + n)) : Math.min(k, 1 - (a + n) / (m + n) % 1));\n          p < q && (k = Math.min(k, Math.abs((p - n) / (q - n))));\n          return k;\n        };\n\n        return e;\n      }();\n\n      a.Composition = F;\n      a.defaultOptions = {\n        chart: {\n          options3d: {\n            enabled: !1,\n            alpha: 0,\n            beta: 0,\n            depth: 100,\n            fitToPlot: !0,\n            viewDistance: 25,\n            axisLabelPosition: null,\n            frame: {\n              visible: \"default\",\n              size: 1,\n              bottom: {},\n              top: {},\n              left: {},\n              right: {},\n              back: {},\n              front: {}\n            }\n          }\n        }\n      };\n\n      a.compose = function (b, f) {\n        var g = b.prototype;\n        f = f.prototype;\n\n        g.is3d = function () {\n          return !(!this.options.chart.options3d || !this.options.chart.options3d.enabled);\n        };\n\n        g.propsRequireDirtyBox.push(\"chart.options3d\");\n        g.propsRequireUpdateSeries.push(\"chart.options3d\");\n\n        f.matrixSetter = function () {\n          if (1 > this.pos && (d(this.start) || d(this.end))) {\n            var b = this.start || [1, 0, 0, 1, 0, 0],\n                e = this.end || [1, 0, 0, 1, 0, 0];\n            var c = [];\n\n            for (var a = 0; 6 > a; a++) c.push(this.pos * e[a] + (1 - this.pos) * b[a]);\n          } else c = this.end;\n\n          this.elem.attr(this.prop, c, null, !0);\n        };\n\n        c(!0, x, a.defaultOptions);\n        k(b, \"init\", B);\n        k(b, \"addSeries\", e);\n        k(b, \"afterDrawChartBox\", n);\n        k(b, \"afterGetContainer\", u);\n        k(b, \"afterInit\", p);\n        k(b, \"afterSetChartSize\", q);\n        k(b, \"beforeRedraw\", C);\n        k(b, \"beforeRender\", A);\n        l(g, \"isInsidePlot\", m);\n        l(b, \"renderSeries\", t);\n        l(b, \"setClassName\", w);\n      };\n    })(q || (q = {}));\n\n    \"\";\n    return q;\n  });\n  E(a, \"Core/Axis/ZAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Utilities.js\"]], function (a, w) {\n    var t = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var a in c) c.hasOwnProperty(a) && (b[a] = c[a]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (d.prototype = b.prototype, new d());\n      };\n    }(),\n        F = w.addEvent,\n        f = w.merge,\n        z = w.pick,\n        v = w.splat,\n        x = function () {\n      function a() {}\n\n      a.compose = function (c) {\n        F(c, \"afterGetAxes\", a.onAfterGetAxes);\n        c = c.prototype;\n        c.addZAxis = a.wrapAddZAxis;\n        c.collectionsWithInit.zAxis = [c.addZAxis];\n        c.collectionsWithUpdate.push(\"zAxis\");\n      };\n\n      a.onAfterGetAxes = function () {\n        var c = this,\n            b = this.options;\n        b = b.zAxis = v(b.zAxis || {});\n        c.is3d() && (c.zAxis = [], b.forEach(function (b, a) {\n          b.index = a;\n          b.isX = !0;\n          c.addZAxis(b).setScale();\n        }));\n      };\n\n      a.wrapAddZAxis = function (c) {\n        return new k(this, c);\n      };\n\n      return a;\n    }(),\n        k = function (a) {\n      function c(b, c) {\n        b = a.call(this, b, c) || this;\n        b.isZAxis = !0;\n        return b;\n      }\n\n      t(c, a);\n\n      c.prototype.getSeriesExtremes = function () {\n        var b = this,\n            c = b.chart;\n        b.hasVisibleSeries = !1;\n        b.dataMin = b.dataMax = b.ignoreMinPadding = b.ignoreMaxPadding = void 0;\n        b.stacking && b.stacking.buildStacks();\n        b.series.forEach(function (a) {\n          if (a.visible || !c.options.chart.ignoreHiddenSeries) b.hasVisibleSeries = !0, a = a.zData, a.length && (b.dataMin = Math.min(z(b.dataMin, a[0]), Math.min.apply(null, a)), b.dataMax = Math.max(z(b.dataMax, a[0]), Math.max.apply(null, a)));\n        });\n      };\n\n      c.prototype.setAxisSize = function () {\n        var b = this.chart;\n        a.prototype.setAxisSize.call(this);\n        this.width = this.len = b.options.chart.options3d && b.options.chart.options3d.depth || 0;\n        this.right = b.chartWidth - this.width - this.left;\n      };\n\n      c.prototype.setOptions = function (b) {\n        b = f({\n          offset: 0,\n          lineWidth: 0\n        }, b);\n        this.isZAxis = !0;\n        a.prototype.setOptions.call(this, b);\n        this.coll = \"zAxis\";\n      };\n\n      c.ZChartComposition = x;\n      return c;\n    }(a);\n\n    return k;\n  });\n  E(a, \"Core/Axis/Tick3D.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var w = a.addEvent,\n        t = a.extend,\n        F = a.wrap;\n    return function () {\n      function a() {}\n\n      a.compose = function (f) {\n        w(f, \"afterGetLabelPosition\", a.onAfterGetLabelPosition);\n        F(f.prototype, \"getMarkPath\", a.wrapGetMarkPath);\n      };\n\n      a.onAfterGetLabelPosition = function (a) {\n        var f = this.axis.axis3D;\n        f && t(a.pos, f.fix3dPosition(a.pos));\n      };\n\n      a.wrapGetMarkPath = function (a) {\n        var f = this.axis.axis3D,\n            t = a.apply(this, [].slice.call(arguments, 1));\n\n        if (f) {\n          var k = t[0],\n              d = t[1];\n          if (\"M\" === k[0] && \"L\" === d[0]) return f = [f.fix3dPosition({\n            x: k[1],\n            y: k[2],\n            z: 0\n          }), f.fix3dPosition({\n            x: d[1],\n            y: d[2],\n            z: 0\n          })], this.axis.chart.renderer.toLineSegments(f);\n        }\n\n        return t;\n      };\n\n      return a;\n    }();\n  });\n  E(a, \"Core/Axis/Axis3D.js\", [a[\"Core/Globals.js\"], a[\"Extensions/Math3D.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Axis/Tick3D.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D, f) {\n    var z = a.deg2rad,\n        v = w.perspective,\n        x = w.perspective3D,\n        k = w.shapeArea,\n        d = f.addEvent,\n        c = f.merge,\n        b = f.pick,\n        l = f.wrap,\n        q = function () {\n      function c(b) {\n        this.axis = b;\n      }\n\n      c.prototype.fix3dPosition = function (e, c) {\n        var a = this.axis,\n            d = a.chart;\n        if (\"colorAxis\" === a.coll || !d.chart3d || !d.is3d()) return e;\n        var n = z * d.options.chart.options3d.alpha,\n            f = z * d.options.chart.options3d.beta,\n            q = b(c && a.options.title.position3d, a.options.labels.position3d);\n        c = b(c && a.options.title.skew3d, a.options.labels.skew3d);\n        var l = d.chart3d.frame3d,\n            m = d.plotLeft,\n            t = d.plotWidth + m,\n            A = d.plotTop,\n            x = d.plotHeight + A,\n            h = d = 0,\n            r = {\n          x: 0,\n          y: 1,\n          z: 0\n        },\n            g = !1;\n        e = a.axis3D.swapZ({\n          x: e.x,\n          y: e.y,\n          z: 0\n        });\n        if (a.isZAxis) {\n          if (a.opposite) {\n            if (null === l.axes.z.top) return {};\n            h = e.y - A;\n            e.x = l.axes.z.top.x;\n            e.y = l.axes.z.top.y;\n            m = l.axes.z.top.xDir;\n            g = !l.top.frontFacing;\n          } else {\n            if (null === l.axes.z.bottom) return {};\n            h = e.y - x;\n            e.x = l.axes.z.bottom.x;\n            e.y = l.axes.z.bottom.y;\n            m = l.axes.z.bottom.xDir;\n            g = !l.bottom.frontFacing;\n          }\n        } else if (a.horiz) {\n          if (a.opposite) {\n            if (null === l.axes.x.top) return {};\n            h = e.y - A;\n            e.y = l.axes.x.top.y;\n            e.z = l.axes.x.top.z;\n            m = l.axes.x.top.xDir;\n            g = !l.top.frontFacing;\n          } else {\n            if (null === l.axes.x.bottom) return {};\n            h = e.y - x;\n            e.y = l.axes.x.bottom.y;\n            e.z = l.axes.x.bottom.z;\n            m = l.axes.x.bottom.xDir;\n            g = !l.bottom.frontFacing;\n          }\n        } else if (a.opposite) {\n          if (null === l.axes.y.right) return {};\n          d = e.x - t;\n          e.x = l.axes.y.right.x;\n          e.z = l.axes.y.right.z;\n          m = l.axes.y.right.xDir;\n          m = {\n            x: m.z,\n            y: m.y,\n            z: -m.x\n          };\n        } else {\n          if (null === l.axes.y.left) return {};\n          d = e.x - m;\n          e.x = l.axes.y.left.x;\n          e.z = l.axes.y.left.z;\n          m = l.axes.y.left.xDir;\n        }\n        \"chart\" !== q && (\"flap\" === q ? a.horiz ? (f = Math.sin(n), n = Math.cos(n), a.opposite && (f = -f), g && (f = -f), r = {\n          x: m.z * f,\n          y: n,\n          z: -m.x * f\n        }) : m = {\n          x: Math.cos(f),\n          y: 0,\n          z: Math.sin(f)\n        } : \"ortho\" === q ? a.horiz ? (r = Math.cos(n), q = Math.sin(f) * r, n = -Math.sin(n), f = -r * Math.cos(f), r = {\n          x: m.y * f - m.z * n,\n          y: m.z * q - m.x * f,\n          z: m.x * n - m.y * q\n        }, n = 1 / Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z), g && (n = -n), r = {\n          x: n * r.x,\n          y: n * r.y,\n          z: n * r.z\n        }) : m = {\n          x: Math.cos(f),\n          y: 0,\n          z: Math.sin(f)\n        } : a.horiz ? r = {\n          x: Math.sin(f) * Math.sin(n),\n          y: Math.cos(n),\n          z: -Math.cos(f) * Math.sin(n)\n        } : m = {\n          x: Math.cos(f),\n          y: 0,\n          z: Math.sin(f)\n        });\n        e.x += d * m.x + h * r.x;\n        e.y += d * m.y + h * r.y;\n        e.z += d * m.z + h * r.z;\n        d = v([e], a.chart)[0];\n        c && (0 > k(v([e, {\n          x: e.x + m.x,\n          y: e.y + m.y,\n          z: e.z + m.z\n        }, {\n          x: e.x + r.x,\n          y: e.y + r.y,\n          z: e.z + r.z\n        }], a.chart)) && (m = {\n          x: -m.x,\n          y: -m.y,\n          z: -m.z\n        }), e = v([{\n          x: e.x,\n          y: e.y,\n          z: e.z\n        }, {\n          x: e.x + m.x,\n          y: e.y + m.y,\n          z: e.z + m.z\n        }, {\n          x: e.x + r.x,\n          y: e.y + r.y,\n          z: e.z + r.z\n        }], a.chart), d.matrix = [e[1].x - e[0].x, e[1].y - e[0].y, e[2].x - e[0].x, e[2].y - e[0].y, d.x, d.y], d.matrix[4] -= d.x * d.matrix[0] + d.y * d.matrix[2], d.matrix[5] -= d.x * d.matrix[1] + d.y * d.matrix[3]);\n        return d;\n      };\n\n      c.prototype.swapZ = function (b, a) {\n        var e = this.axis;\n        return e.isZAxis ? (a = a ? 0 : e.chart.plotLeft, {\n          x: a + b.z,\n          y: b.y,\n          z: b.x - a\n        }) : b;\n      };\n\n      return c;\n    }();\n\n    return function () {\n      function a() {}\n\n      a.compose = function (b) {\n        c(!0, b.defaultOptions, a.defaultOptions);\n        b.keepProps.push(\"axis3D\");\n        d(b, \"init\", a.onInit);\n        d(b, \"afterSetOptions\", a.onAfterSetOptions);\n        d(b, \"drawCrosshair\", a.onDrawCrosshair);\n        b = b.prototype;\n        l(b, \"getLinePath\", a.wrapGetLinePath);\n        l(b, \"getPlotBandPath\", a.wrapGetPlotBandPath);\n        l(b, \"getPlotLinePath\", a.wrapGetPlotLinePath);\n        l(b, \"getSlotWidth\", a.wrapGetSlotWidth);\n        l(b, \"getTitlePosition\", a.wrapGetTitlePosition);\n        D.compose(t);\n      };\n\n      a.onAfterSetOptions = function () {\n        var a = this.chart,\n            c = this.options;\n        a.is3d && a.is3d() && \"colorAxis\" !== this.coll && (c.tickWidth = b(c.tickWidth, 0), c.gridLineWidth = b(c.gridLineWidth, 1));\n      };\n\n      a.onDrawCrosshair = function (b) {\n        this.chart.is3d() && \"colorAxis\" !== this.coll && b.point && (b.point.crosshairPos = this.isXAxis ? b.point.axisXpos : this.len - b.point.axisYpos);\n      };\n\n      a.onInit = function () {\n        this.axis3D || (this.axis3D = new q(this));\n      };\n\n      a.wrapGetLinePath = function (b) {\n        return this.chart.is3d() && \"colorAxis\" !== this.coll ? [] : b.apply(this, [].slice.call(arguments, 1));\n      };\n\n      a.wrapGetPlotBandPath = function (b) {\n        if (!this.chart.is3d() || \"colorAxis\" === this.coll) return b.apply(this, [].slice.call(arguments, 1));\n        var a = arguments,\n            c = a[2],\n            e = [];\n        a = this.getPlotLinePath({\n          value: a[1]\n        });\n        c = this.getPlotLinePath({\n          value: c\n        });\n        if (a && c) for (var d = 0; d < a.length; d += 2) {\n          var f = a[d],\n              l = a[d + 1],\n              k = c[d],\n              m = c[d + 1];\n          \"M\" === f[0] && \"L\" === l[0] && \"M\" === k[0] && \"L\" === m[0] && e.push(f, l, m, [\"L\", k[1], k[2]], [\"Z\"]);\n        }\n        return e;\n      };\n\n      a.wrapGetPlotLinePath = function (b) {\n        var a = this.axis3D,\n            c = this.chart,\n            e = b.apply(this, [].slice.call(arguments, 1));\n        if (\"colorAxis\" === this.coll || !c.chart3d || !c.is3d() || null === e) return e;\n        var d = c.options.chart.options3d,\n            f = this.isZAxis ? c.plotWidth : d.depth;\n        d = c.chart3d.frame3d;\n        var l = e[0],\n            k = e[1];\n        e = [];\n        \"M\" === l[0] && \"L\" === k[0] && (a = [a.swapZ({\n          x: l[1],\n          y: l[2],\n          z: 0\n        }), a.swapZ({\n          x: l[1],\n          y: l[2],\n          z: f\n        }), a.swapZ({\n          x: k[1],\n          y: k[2],\n          z: 0\n        }), a.swapZ({\n          x: k[1],\n          y: k[2],\n          z: f\n        })], this.horiz ? (this.isZAxis ? (d.left.visible && e.push(a[0], a[2]), d.right.visible && e.push(a[1], a[3])) : (d.front.visible && e.push(a[0], a[2]), d.back.visible && e.push(a[1], a[3])), d.top.visible && e.push(a[0], a[1]), d.bottom.visible && e.push(a[2], a[3])) : (d.front.visible && e.push(a[0], a[2]), d.back.visible && e.push(a[1], a[3]), d.left.visible && e.push(a[0], a[1]), d.right.visible && e.push(a[2], a[3])), e = v(e, this.chart, !1));\n        return c.renderer.toLineSegments(e);\n      };\n\n      a.wrapGetSlotWidth = function (a, c) {\n        var e = this.chart,\n            d = this.ticks,\n            f = this.gridGroup;\n\n        if (this.categories && e.frameShapes && e.is3d() && f && c && c.label) {\n          f = f.element.childNodes[0].getBBox();\n          var n = e.frameShapes.left.getBBox(),\n              l = e.options.chart.options3d;\n          e = {\n            x: e.plotWidth / 2,\n            y: e.plotHeight / 2,\n            z: l.depth / 2,\n            vd: b(l.depth, 1) * b(l.viewDistance, 0)\n          };\n          l = c.pos;\n          var k = d[l - 1],\n              m = d[l + 1],\n              q = d = void 0;\n          0 !== l && k && k.label && k.label.xy && (d = x({\n            x: k.label.xy.x,\n            y: k.label.xy.y,\n            z: null\n          }, e, e.vd));\n          m && m.label && m.label.xy && (q = x({\n            x: m.label.xy.x,\n            y: m.label.xy.y,\n            z: null\n          }, e, e.vd));\n          l = {\n            x: c.label.xy.x,\n            y: c.label.xy.y,\n            z: null\n          };\n          l = x(l, e, e.vd);\n          return Math.abs(d ? l.x - d.x : q ? q.x - l.x : f.x - n.x);\n        }\n\n        return a.apply(this, [].slice.call(arguments, 1));\n      };\n\n      a.wrapGetTitlePosition = function (b) {\n        var a = b.apply(this, [].slice.call(arguments, 1));\n        return this.axis3D ? this.axis3D.fix3dPosition(a, !0) : a;\n      };\n\n      a.defaultOptions = {\n        labels: {\n          position3d: \"offset\",\n          skew3d: !1\n        },\n        title: {\n          position3d: null,\n          skew3d: null\n        }\n      };\n      return a;\n    }();\n  });\n  E(a, \"Core/Series/Series3D.js\", [a[\"Extensions/Math3D.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, w, t) {\n    var F = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (d.prototype = b.prototype, new d());\n      };\n    }(),\n        f = a.perspective;\n\n    a = t.addEvent;\n    var z = t.extend,\n        v = t.merge,\n        x = t.pick,\n        k = t.isNumber;\n\n    t = function (a) {\n      function c() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      F(c, a);\n\n      c.prototype.translate = function () {\n        a.prototype.translate.apply(this, arguments);\n        this.chart.is3d() && this.translate3dPoints();\n      };\n\n      c.prototype.translate3dPoints = function () {\n        var b = this.options,\n            a = this.chart,\n            c = x(this.zAxis, a.options.zAxis[0]),\n            d = [],\n            e,\n            n = [];\n        this.zPadding = (b.stacking ? k(b.stack) ? b.stack : 0 : this.index || 0) * (b.depth || 0 + (b.groupZPadding || 1));\n\n        for (e = 0; e < this.data.length; e++) {\n          b = this.data[e];\n\n          if (c && c.translate) {\n            var u = c.logarithmic && c.val2lin ? c.val2lin(b.z) : b.z;\n            b.plotZ = c.translate(u);\n            b.isInside = b.isInside ? u >= c.min && u <= c.max : !1;\n          } else b.plotZ = this.zPadding;\n\n          b.axisXpos = b.plotX;\n          b.axisYpos = b.plotY;\n          b.axisZpos = b.plotZ;\n          d.push({\n            x: b.plotX,\n            y: b.plotY,\n            z: b.plotZ\n          });\n          n.push(b.plotX || 0);\n        }\n\n        this.rawPointsX = n;\n        a = f(d, a, !0);\n\n        for (e = 0; e < this.data.length; e++) b = this.data[e], c = a[e], b.plotX = c.x, b.plotY = c.y, b.plotZ = c.z;\n      };\n\n      c.defaultOptions = v(w.defaultOptions);\n      return c;\n    }(w);\n\n    a(w, \"afterTranslate\", function () {\n      this.chart.is3d() && this.translate3dPoints();\n    });\n    z(w.prototype, {\n      translate3dPoints: t.prototype.translate3dPoints\n    });\n    return t;\n  });\n  E(a, \"Series/Column3D/Column3DComposition.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Extensions/Math3D.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Extensions/Stacking.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D, f, z, v) {\n    function x(b, a) {\n      var c = b.series,\n          e = {\n        totalStacks: 0\n      },\n          d,\n          f = 1;\n      c.forEach(function (b) {\n        d = A(b.options.stack, a ? 0 : c.length - 1 - b.index);\n        e[d] ? e[d].series.push(b) : (e[d] = {\n          series: [b],\n          position: f\n        }, f++);\n      });\n      e.totalStacks = f + 1;\n      return e;\n    }\n\n    function k(b) {\n      var a = b.apply(this, [].slice.call(arguments, 1));\n      this.chart.is3d && this.chart.is3d() && (a.stroke = this.options.edgeColor || a.fill, a[\"stroke-width\"] = A(this.options.edgeWidth, 1));\n      return a;\n    }\n\n    function d(b, a, c) {\n      var e = this.chart.is3d && this.chart.is3d();\n      e && (this.options.inactiveOtherPoints = !0);\n      b.call(this, a, c);\n      e && (this.options.inactiveOtherPoints = !1);\n    }\n\n    function c(b) {\n      for (var a = [], c = 1; c < arguments.length; c++) a[c - 1] = arguments[c];\n\n      return this.series.chart.is3d() ? this.graphic && \"g\" !== this.graphic.element.nodeName : b.apply(this, a);\n    }\n\n    var b = a.prototype,\n        l = w.svg,\n        q = D.perspective;\n    w = v.addEvent;\n    var A = v.pick;\n    v = v.wrap;\n    v(b, \"translate\", function (b) {\n      b.apply(this, [].slice.call(arguments, 1));\n      this.chart.is3d() && this.translate3dShapes();\n    });\n    v(t.prototype, \"justifyDataLabel\", function (b) {\n      return arguments[2].outside3dPlot ? !1 : b.apply(this, [].slice.call(arguments, 1));\n    });\n\n    b.translate3dPoints = function () {};\n\n    b.translate3dShapes = function () {\n      var b = this,\n          a = b.chart,\n          c = b.options,\n          d = c.depth,\n          f = (c.stacking ? c.stack || 0 : b.index) * (d + (c.groupZPadding || 1)),\n          k = b.borderWidth % 2 ? .5 : 0,\n          l;\n      a.inverted && !b.yAxis.reversed && (k *= -1);\n      !1 !== c.grouping && (f = 0);\n      f += c.groupZPadding || 1;\n      b.data.forEach(function (c) {\n        c.outside3dPlot = null;\n\n        if (null !== c.y) {\n          var e = c.shapeArgs,\n              n = c.tooltipPos,\n              p;\n          [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (a) {\n            p = e[a[0]] - k;\n            0 > p && (e[a[1]] += e[a[0]] + k, e[a[0]] = -k, p = 0);\n            p + e[a[1]] > b[a[0] + \"Axis\"].len && 0 !== e[a[1]] && (e[a[1]] = b[a[0] + \"Axis\"].len - e[a[0]]);\n\n            if (0 !== e[a[1]] && (e[a[0]] >= b[a[0] + \"Axis\"].len || e[a[0]] + e[a[1]] <= k)) {\n              for (var d in e) e[d] = \"y\" === d ? -9999 : 0;\n\n              c.outside3dPlot = !0;\n            }\n          });\n          \"rect\" === c.shapeType && (c.shapeType = \"cuboid\");\n          e.z = f;\n          e.depth = d;\n          e.insidePlotArea = !0;\n          l = {\n            x: e.x + e.width / 2,\n            y: e.y,\n            z: f + d / 2\n          };\n          a.inverted && (l.x = e.height, l.y = c.clientX);\n          c.plot3d = q([l], a, !0, !1)[0];\n          n = q([{\n            x: n[0],\n            y: n[1],\n            z: f + d / 2\n          }], a, !0, !1)[0];\n          c.tooltipPos = [n.x, n.y];\n        }\n      });\n      b.z = f;\n    };\n\n    v(b, \"animate\", function (b) {\n      if (this.chart.is3d()) {\n        var a = arguments[1],\n            c = this.yAxis,\n            e = this,\n            d = this.yAxis.reversed;\n        l && (a ? e.data.forEach(function (b) {\n          null !== b.y && (b.height = b.shapeArgs.height, b.shapey = b.shapeArgs.y, b.shapeArgs.height = 1, d || (b.shapeArgs.y = b.stackY ? b.plotY + c.translate(b.stackY) : b.plotY + (b.negative ? -b.height : b.height)));\n        }) : (e.data.forEach(function (b) {\n          if (null !== b.y && (b.shapeArgs.height = b.height, b.shapeArgs.y = b.shapey, b.graphic)) b.graphic[b.outside3dPlot ? \"attr\" : \"animate\"](b.shapeArgs, e.options.animation);\n        }), this.drawDataLabels()));\n      } else b.apply(this, [].slice.call(arguments, 1));\n    });\n    v(b, \"plotGroup\", function (b, a, c, d, f, k) {\n      \"dataLabelsGroup\" !== a && this.chart.is3d() && (this[a] && delete this[a], k && (this.chart.columnGroup || (this.chart.columnGroup = this.chart.renderer.g(\"columnGroup\").add(k)), this[a] = this.chart.columnGroup, this.chart.columnGroup.attr(this.getPlotBox()), this[a].survive = !0, \"group\" === a || \"markerGroup\" === a)) && (arguments[3] = \"visible\");\n      return b.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n    v(b, \"setVisible\", function (b, a) {\n      var c = this;\n      c.chart.is3d() && c.data.forEach(function (b) {\n        b.visible = b.options.visible = a = \"undefined\" === typeof a ? !A(c.visible, b.visible) : a;\n        c.options.data[c.data.indexOf(b)] = b.options;\n        b.graphic && b.graphic.attr({\n          visibility: a ? \"visible\" : \"hidden\"\n        });\n      });\n      b.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n    w(a, \"afterInit\", function () {\n      if (this.chart.is3d()) {\n        var b = this.options,\n            a = b.grouping,\n            c = b.stacking,\n            d = this.yAxis.options.reversedStacks,\n            f = 0;\n\n        if (\"undefined\" === typeof a || a) {\n          a = x(this.chart, c);\n          f = b.stack || 0;\n\n          for (c = 0; c < a[f].series.length && a[f].series[c] !== this; c++);\n\n          f = 10 * (a.totalStacks - a[f].position) + (d ? c : -c);\n          this.xAxis.reversed || (f = 10 * a.totalStacks - f);\n        }\n\n        b.depth = b.depth || 25;\n        this.z = this.z || 0;\n        b.zIndex = f;\n      }\n    });\n    v(b, \"pointAttribs\", k);\n    v(b, \"setState\", d);\n    v(b.pointClass.prototype, \"hasNewShapeType\", c);\n    f.seriesTypes.columnRange && (w = f.seriesTypes.columnrange.prototype, v(w, \"pointAttribs\", k), v(w, \"setState\", d), v(w.pointClass.prototype, \"hasNewShapeType\", c), w.plotGroup = b.plotGroup, w.setVisible = b.setVisible);\n    v(t.prototype, \"alignDataLabel\", function (b, a, c, d, f) {\n      var e = this.chart;\n      d.outside3dPlot = a.outside3dPlot;\n\n      if (e.is3d() && this.is(\"column\")) {\n        var k = this.options,\n            l = A(d.inside, !!this.options.stacking),\n            m = e.options.chart.options3d,\n            p = a.pointWidth / 2 || 0;\n        k = {\n          x: f.x + p,\n          y: f.y,\n          z: this.z + k.depth / 2\n        };\n        e.inverted && (l && (f.width = 0, k.x += a.shapeArgs.height / 2), 90 <= m.alpha && 270 >= m.alpha && (k.y += a.shapeArgs.width));\n        k = q([k], e, !0, !1)[0];\n        f.x = k.x - p;\n        f.y = a.outside3dPlot ? -9E9 : k.y;\n      }\n\n      b.apply(this, [].slice.call(arguments, 1));\n    });\n    v(z.prototype, \"getStackBox\", function (b, a, c, d, k, l, t, v) {\n      var e = b.apply(this, [].slice.call(arguments, 1));\n\n      if (a.is3d() && c.base) {\n        var p = +c.base.split(\",\")[0],\n            n = a.series[p];\n        p = a.options.chart.options3d;\n        n && n instanceof f.seriesTypes.column && (n = {\n          x: e.x + (a.inverted ? t : l / 2),\n          y: e.y,\n          z: n.options.depth / 2\n        }, a.inverted && (e.width = 0, 90 <= p.alpha && 270 >= p.alpha && (n.y += l)), n = q([n], a, !0, !1)[0], e.x = n.x - l / 2, e.y = n.y);\n      }\n\n      return e;\n    });\n    \"\";\n    return a;\n  });\n  E(a, \"Series/Pie3D/Pie3DPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var w = this && this.__extends || function () {\n      var a = function (f, t) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, f) {\n          a.__proto__ = f;\n        } || function (a, f) {\n          for (var k in f) f.hasOwnProperty(k) && (a[k] = f[k]);\n        };\n\n        return a(f, t);\n      };\n\n      return function (f, t) {\n        function v() {\n          this.constructor = f;\n        }\n\n        a(f, t);\n        f.prototype = null === t ? Object.create(t) : (v.prototype = t.prototype, new v());\n      };\n    }();\n\n    a = a.seriesTypes.pie.prototype.pointClass;\n    var t = a.prototype.haloPath;\n    return function (a) {\n      function f() {\n        var f = null !== a && a.apply(this, arguments) || this;\n        f.series = void 0;\n        return f;\n      }\n\n      w(f, a);\n\n      f.prototype.haloPath = function () {\n        return this.series.chart.is3d() ? [] : t.apply(this, arguments);\n      };\n\n      return f;\n    }(a);\n  });\n  E(a, \"Series/Pie3D/Pie3DSeries.js\", [a[\"Core/Globals.js\"], a[\"Series/Pie3D/Pie3DPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D) {\n    var f = this && this.__extends || function () {\n      var a = function (d, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);\n        };\n\n        return a(d, c);\n      };\n\n      return function (d, c) {\n        function b() {\n          this.constructor = d;\n        }\n\n        a(d, c);\n        d.prototype = null === c ? Object.create(c) : (b.prototype = c.prototype, new b());\n      };\n    }(),\n        z = a.deg2rad,\n        v = a.svg;\n\n    a = D.extend;\n    var x = D.pick;\n\n    t = function (a) {\n      function d() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      f(d, a);\n\n      d.prototype.addPoint = function () {\n        a.prototype.addPoint.apply(this, arguments);\n        this.chart.is3d() && this.update(this.userOptions, !0);\n      };\n\n      d.prototype.animate = function (c) {\n        if (this.chart.is3d()) {\n          var b = this.options.animation;\n          var d = this.center;\n          var f = this.group,\n              k = this.markerGroup;\n          v && (!0 === b && (b = {}), c ? (f.oldtranslateX = x(f.oldtranslateX, f.translateX), f.oldtranslateY = x(f.oldtranslateY, f.translateY), d = {\n            translateX: d[0],\n            translateY: d[1],\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(d), k && (k.attrSetters = f.attrSetters, k.attr(d))) : (d = {\n            translateX: f.oldtranslateX,\n            translateY: f.oldtranslateY,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(d, b), k && k.animate(d, b)));\n        } else a.prototype.animate.apply(this, arguments);\n      };\n\n      d.prototype.drawDataLabels = function () {\n        if (this.chart.is3d()) {\n          var c = this.chart.options.chart.options3d;\n          this.data.forEach(function (b) {\n            var a = b.shapeArgs,\n                d = a.r,\n                f = (a.start + a.end) / 2;\n            b = b.labelPosition;\n            var e = b.connectorPosition,\n                k = -d * (1 - Math.cos((a.alpha || c.alpha) * z)) * Math.sin(f),\n                t = d * (Math.cos((a.beta || c.beta) * z) - 1) * Math.cos(f);\n            [b.natural, e.breakAt, e.touchingSliceAt].forEach(function (b) {\n              b.x += t;\n              b.y += k;\n            });\n          });\n        }\n\n        a.prototype.drawDataLabels.apply(this, arguments);\n      };\n\n      d.prototype.pointAttribs = function (c) {\n        var b = a.prototype.pointAttribs.apply(this, arguments),\n            d = this.options;\n        this.chart.is3d() && !this.chart.styledMode && (b.stroke = d.edgeColor || c.color || this.color, b[\"stroke-width\"] = x(d.edgeWidth, 1));\n        return b;\n      };\n\n      d.prototype.translate = function () {\n        a.prototype.translate.apply(this, arguments);\n\n        if (this.chart.is3d()) {\n          var c = this,\n              b = c.options,\n              d = b.depth || 0,\n              f = c.chart.options.chart.options3d,\n              k = f.alpha,\n              e = f.beta,\n              n = b.stacking ? (b.stack || 0) * d : c._i * d;\n          n += d / 2;\n          !1 !== b.grouping && (n = 0);\n          c.data.forEach(function (a) {\n            var f = a.shapeArgs;\n            a.shapeType = \"arc3d\";\n            f.z = n;\n            f.depth = .75 * d;\n            f.alpha = k;\n            f.beta = e;\n            f.center = c.center;\n            f = (f.end + f.start) / 2;\n            a.slicedTranslation = {\n              translateX: Math.round(Math.cos(f) * b.slicedOffset * Math.cos(k * z)),\n              translateY: Math.round(Math.sin(f) * b.slicedOffset * Math.cos(k * z))\n            };\n          });\n        }\n      };\n\n      d.prototype.drawTracker = function () {\n        a.prototype.drawTracker.apply(this, arguments);\n        this.chart.is3d() && this.points.forEach(function (a) {\n          a.graphic && [\"out\", \"inn\", \"side1\", \"side2\"].forEach(function (b) {\n            a.graphic && (a.graphic[b].element.point = a);\n          });\n        });\n      };\n\n      return d;\n    }(t.seriesTypes.pie);\n\n    a(t.prototype, {\n      pointClass: w\n    });\n    \"\";\n    return t;\n  });\n  E(a, \"Series/Pie3D/Pie3DComposition.js\", [a[\"Series/Pie3D/Pie3DPoint.js\"], a[\"Series/Pie3D/Pie3DSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"]], function (a, w, t) {\n    t.seriesTypes.pie.prototype.pointClass.prototype.haloPath = a.prototype.haloPath;\n    t.seriesTypes.pie = w;\n  });\n  E(a, \"Series/Scatter3D/Scatter3DPoint.js\", [a[\"Series/Scatter/ScatterSeries.js\"], a[\"Core/Utilities.js\"]], function (a, w) {\n    var t = this && this.__extends || function () {\n      var a = function (f, t) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, f) {\n          a.__proto__ = f;\n        } || function (a, f) {\n          for (var d in f) f.hasOwnProperty(d) && (a[d] = f[d]);\n        };\n\n        return a(f, t);\n      };\n\n      return function (f, t) {\n        function v() {\n          this.constructor = f;\n        }\n\n        a(f, t);\n        f.prototype = null === t ? Object.create(t) : (v.prototype = t.prototype, new v());\n      };\n    }(),\n        F = w.defined;\n\n    return function (a) {\n      function f() {\n        var f = null !== a && a.apply(this, arguments) || this;\n        f.options = void 0;\n        f.series = void 0;\n        return f;\n      }\n\n      t(f, a);\n\n      f.prototype.applyOptions = function () {\n        a.prototype.applyOptions.apply(this, arguments);\n        F(this.z) || (this.z = 0);\n        return this;\n      };\n\n      return f;\n    }(a.prototype.pointClass);\n  });\n  E(a, \"Series/Scatter3D/Scatter3DSeries.js\", [a[\"Extensions/Math3D.js\"], a[\"Series/Scatter3D/Scatter3DPoint.js\"], a[\"Series/Scatter/ScatterSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, w, t, D, f) {\n    var z = this && this.__extends || function () {\n      var a = function (d, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return a(d, c);\n      };\n\n      return function (d, c) {\n        function b() {\n          this.constructor = d;\n        }\n\n        a(d, c);\n        d.prototype = null === c ? Object.create(c) : (b.prototype = c.prototype, new b());\n      };\n    }(),\n        v = a.pointCameraDistance;\n\n    a = f.extend;\n    var x = f.merge;\n\n    f = function (a) {\n      function d() {\n        var c = null !== a && a.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      z(d, a);\n\n      d.prototype.pointAttribs = function (c) {\n        var b = a.prototype.pointAttribs.apply(this, arguments);\n        this.chart.is3d() && c && (b.zIndex = v(c, this.chart));\n        return b;\n      };\n\n      d.defaultOptions = x(t.defaultOptions, {\n        tooltip: {\n          pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>\"\n        }\n      });\n      return d;\n    }(t);\n\n    a(f.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\", \"zAxis\"],\n      directTouch: !0,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      pointArrayMap: [\"x\", \"y\", \"z\"],\n      pointClass: w\n    });\n    D.registerSeriesType(\"scatter3d\", f);\n    \"\";\n    return f;\n  });\n  E(a, \"Series/Area3DSeries.js\", [a[\"Extensions/Math3D.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, w, t) {\n    var F = a.perspective;\n    a = w.seriesTypes;\n    var f = a.line,\n        z = t.pick;\n    t = t.wrap;\n    t(a.area.prototype, \"getGraphPath\", function (a) {\n      var t = a.apply(this, [].slice.call(arguments, 1));\n      if (!this.chart.is3d()) return t;\n      var k = f.prototype.getGraphPath,\n          d = this.options;\n      var c = [];\n      var b = [],\n          l = z(d.connectNulls, \"percent\" === d.stacking),\n          q = Math.round(this.yAxis.getThreshold(d.threshold));\n      if (this.rawPointsX) for (var v = 0; v < this.points.length; v++) c.push({\n        x: this.rawPointsX[v],\n        y: d.stacking ? this.points[v].yBottom : q,\n        z: this.zPadding\n      });\n      d = this.chart.options.chart.options3d;\n      c = F(c, this.chart, !0).map(function (a) {\n        return {\n          plotX: a.x,\n          plotY: a.y,\n          plotZ: a.z\n        };\n      });\n      this.group && d && d.depth && d.beta && (this.markerGroup && (this.markerGroup.add(this.group), this.markerGroup.attr({\n        translateX: 0,\n        translateY: 0\n      })), this.group.attr({\n        zIndex: Math.max(1, 270 < d.beta || 90 > d.beta ? d.depth - Math.round(this.zPadding || 0) : Math.round(this.zPadding || 0))\n      }));\n      c.reversed = !0;\n      c = k.call(this, c, !0, !0);\n      c[0] && \"M\" === c[0][0] && (c[0] = [\"L\", c[0][1], c[0][2]]);\n      this.areaPath && (c = this.areaPath.splice(0, this.areaPath.length / 2).concat(c), c.xMap = this.areaPath.xMap, this.areaPath = c, k.call(this, b, !1, l));\n      return t;\n    });\n  });\n  E(a, \"masters/highcharts-3d.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGRenderer3D.js\"], a[\"Core/Chart/Chart3D.js\"], a[\"Core/Axis/ZAxis.js\"], a[\"Core/Axis/Axis3D.js\"]], function (a, w, t, D, f) {\n    w.compose(a.SVGRenderer);\n    t.compose(a.Chart, a.Fx);\n    D.ZChartComposition.compose(a.Chart);\n    f.compose(a.Axis);\n  });\n}); //# sourceMappingURL=highcharts-3d.js.map","map":null,"metadata":{},"sourceType":"script"}